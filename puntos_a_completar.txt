21/2
OK Ajustar nuestro servidor principal para trabajar con un sistema de login.
OK - Deberá contar con todas las vistas realizadas en el hands on lab, así también como las rutas de router para procesar el registro y el login. vistas de login, de registro y de perfil.
OK Una vez completado el login, realizar la redirección directamente a la vista de productos.
OK Agregar a la vista de productos un mensaje de bienvenida con los datos del usuario
OK Agregar un sistema de roles, de manera que si colocamos en el login como correo adminCoder@coder.com, y la contraseña adminCod3r123, el usuario de la sesión además tenga un campo 
OK Todos los usuarios que no sean admin deberán contar con un rol “usuario”.
OK Implementar botón de “logout” para destruir la sesión y redirigir a la vista de login
OK Modificar nuestra capa de persistencia para aplicar los conceptos de Factory (opcional), DAO y DTO. 
OK El DAO seleccionado (por un parámetro en línea de comandos como lo hicimos anteriormente) será devuelto por una Factory para que la capa de negocio opere con él. (Factory puede ser opcional)
OK Modificar la ruta  /current Para evitar enviar información sensible, enviar un DTO del usuario sólo con la información necesaria.
OK Realizar un middleware que pueda trabajar en conjunto con la estrategia “current” para hacer un sistema de autorización y delimitar el acceso a dichos endpoints:
OK Sólo el administrador puede crear, actualizar y eliminar productos.
OK Sólo el usuario puede enviar mensajes al chat.
OK Sólo el usuario puede agregar productos a su carrito.
OK Crear un modelo Ticket el cual contará con todas las formalizaciones de la compra. Éste contará con los campos
 - Id (autogenerado por mongo)
 - code: String debe autogenerarse y ser único
 - purchase_datetime: Deberá guardar la fecha y hora exacta en la cual se formalizó la compra (básicamente es un created_at)
 - amount: Number, total de la compra.
 - purchaser: String, contendrá el correo del usuario asociado al carrito.
OK Implementar, en el router de carts, la ruta /:cid/purchase, la cual permitirá finalizar el proceso de compra de dicho carrito.
OK La compra debe corroborar el stock del producto al momento de finalizarse
OK Si el producto tiene suficiente stock para la cantidad indicada en el producto del carrito, entonces restarlo del stock del producto y continuar.
OK Si el producto no tiene suficiente stock para la cantidad indicada en el producto del carrito, entonces no agregar el producto al proceso de compra. 
OK Al final, utilizar el servicio de Tickets para poder generar un ticket con los datos de la compra.
OK En caso de existir una compra no completada, devolver el arreglo con los ids de los productos que no pudieron procesarse.
OK Una vez finalizada la compra, el carrito asociado al usuario que compró deberá contener sólo los productos que no pudieron comprarse. Es decir, se filtran los que sí se compraron y se quedan aquellos que no tenían disponibilidad.
OK Generar un módulo de Mocking para el servidor, con el fin de que, al inicializarse pueda generar y entregar 100 productos con el mismo formato que entregaría una petición de Mongo. Ésto solo debe ocurrir en un endpoint determinado (‘/mockingproducts’)
OK- Primero, definir un sistema de niveles que tenga la siguiente prioridad (de menor a mayor):
debug, http, info, warning, error, fatal


Temas que puede que quedaron colgados:
Actualizar productos por parte del administrador
Implementar el patrón Repository para trabajar con el DAO en la lógica de negocio. 


Pendientes
- Generar un customizador de errores y crear un diccionario para tus errores más comunes al crear un producto, agregarlo al carrito, etc.
- Implementar un logger para desarrollo y un logger para producción, el logger de desarrollo deberá loggear a partir del nivel debug, sólo en consola
- Sin embargo, el logger del entorno productivo debería loggear sólo a partir de nivel info.
- Además, el logger deberá enviar en un transporte de archivos a partir del nivel de error en un nombre “errors.log”
- Agregar logs de valor alto en los puntos importantes de tu servidor (errores, advertencias, etc) y modificar los console.log() habituales que tenemos para que muestren todo a partir de winston.
- Crear un endpoint /loggerTest que permita probar todos los logs

Realizar un sistema de recuperación de contraseña, la cual envíe por medio de un correo un botón que redireccione a una página para restablecer la contraseña (no recuperarla).
link del correo debe expirar después de 1 hora de enviado.
Si se trata de restablecer la contraseña con la misma contraseña del usuario, debe impedirlo e indicarle que no se puede colocar la misma contraseña
Si el link expiró, debe redirigir a una vista que le permita generar nuevamente el correo de restablecimiento, el cual contará con una nueva duración de 1 hora.

Establecer un nuevo rol para el schema del usuario llamado “premium” el cual estará habilitado también para crear productos
Modificar el schema de producto para contar con un campo “owner”, el cual haga referencia a la persona que creó el producto
Si un producto se crea sin owner, se debe colocar por defecto “admin”.
El campo owner deberá guardar sólo el correo electrónico (o _id, lo dejamos a tu conveniencia) del usuario que lo haya creado (Sólo podrá recibir usuarios premium)

Modificar los permisos de modificación y eliminación de productos para que:
Un usuario premium sólo pueda borrar los productos que le pertenecen.
El admin pueda borrar cualquier producto, aún si es de un owner.
Además, modificar la lógica de carrito para que un usuario premium NO pueda agregar a su carrito un producto que le pertenece
Implementar una nueva ruta en el router de api/users, la cual será /api/users/premium/:uid  la cual permitirá cambiar el rol de un usuario, de “user” a “premium” y viceversa.

Video de entrega final:
En el ppunto del router de usuarios: es importante que haya un dto involucrado para una correcta división de capas.
El método delete para limpiar usuarios que no se conectan hace 2 dias, que sea solo accesible por un admin
Vistas de flujo de compras: visualizacio del producto, agregado al carrito, visualizacion de lcarrito....
registro y login, visualizacion del prod, compra. 

No es necesario vistas que corresponden a modulos que no son influyentes en el proceso de compras. 
las necesarias son las que, dde que me registro hasta que compro, todo lo que esté involucrado.

Realizar la configuración necesaria para tener documentado tu proyecto final a partir de Swagger.
Se debe tener documentado el módulo de productos.
Se debe tener documentado el módulo de carrito
No realizar documentación de sesiones

Realizar módulos de testing para tu proyecto principal, utilizando los módulos de mocha + chai + supertest
Se deben incluir por lo menos 3 tests desarrollados para:
Router de products.
Router de carts.
Router de sessions.
No desarrollar únicamente tests de status, la idea es trabajar lo mejor desarrollado posible las validaciones de testing

Mover la ruta suelta /api/users/premium/:uid a un router específico para usuarios en /api/users/
Modificar el modelo de User para que cuente con una nueva propiedad “documents” el cual será un array que contenga los objetos con las siguientes propiedades
name: String (Nombre del documento).
reference: String (link al documento).
No es necesario crear un nuevo modelo de Mongoose para éste.
Además, agregar una propiedad al usuario llamada “last_connection”, la cual deberá modificarse cada vez que el usuario realice un proceso de login y logout
Crear un endpoint en el router de usuarios api/users/:uid/documents con el método POST que permita subir uno o múltiples archivos. Utilizar el middleware de Multer para poder recibir los documentos que se carguen y actualizar en el usuario su status para hacer saber que ya subió algún documento en particular.
El middleware de multer deberá estar modificado para que pueda guardar en diferentes carpetas los diferentes archivos que se suban.
Si se sube una imagen de perfil, deberá guardarlo en una carpeta profiles, en caso de recibir la imagen de un producto, deberá guardarlo en una carpeta products, mientras que ahora al cargar un documento, multer los guardará en una carpeta documents.
Modificar el endpoint /api/users/premium/:uid   para que sólo actualice al usuario a premium si ya ha cargado los siguientes documentos:
Identificación, Comprobante de domicilio, Comprobante de estado de cuenta
En caso de llamar al endpoint, si no se ha terminado de cargar la documentación, devolver un error indicando que el usuario no ha terminado de procesar su documentación. 
(Sólo si quiere pasar de user a premium, no al revés)

Desde el router de /api/users, crear tres rutas:
GET  /  deberá obtener todos los usuarios, éste sólo debe devolver los datos principales como nombre, correo, tipo de cuenta (rol)
DELETE / deberá limpiar a todos los usuarios que no hayan tenido conexión en los últimos 2 días. (puedes hacer pruebas con los últimos 30 minutos, por ejemplo). Deberá enviarse un correo indicando al usuario que su cuenta ha sido eliminada por inactividad
Crear una vista para poder visualizar, modificar el rol y eliminar un usuario. Esta vista únicamente será accesible para el administrador del ecommerce

Modificar el endpoint que elimina productos, para que, en caso de que el producto pertenezca a un usuario premium, le envíe un correo indicándole que el producto fue eliminado.
Finalizarre las vistas pendientes para la alización de flujo completo de compra. NO ES NECESARIO tener una estructura específica de vistas, sólo las que tú consideres necesarias para poder llevar a cabo el proceso de compra.
No es necesario desarrollar vistas para módulos que no influyan en el proceso de compra (Como vistas de usuarios premium para crear productos, o vistas de panel de admin para updates de productos, etc)
Realizar el despliegue de tu aplicativo en la plataforma de tu elección (Preferentemente Railway.app, pues es la abarcada en el curso) y corroborar que se puede llevar a cabo un proceso de compra completo.
